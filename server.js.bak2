
/* FinanceEase full backend (SQLite + Knex + JWT) */
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
const fs = require('fs');
const Knex = require('knex');

const PORT = process.env.PORT || 4001;
const JWT_SECRET = process.env.JWT_SECRET || 'dev_jwt_secret_change_me';
const BCRYPT_ROUNDS = parseInt(process.env.BCRYPT_ROUNDS || '10', 10);

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// serve static frontend
app.use(express.static(path.join(__dirname, 'public')));

// --- Knex / SQLite setup
const DB_DIR = path.join(__dirname, 'data');
if (!fs.existsSync(DB_DIR)) fs.mkdirSync(DB_DIR);

const knex = Knex({
  client: 'sqlite3',
  connection: { filename: path.join(DB_DIR, 'finance.db') },
  useNullAsDefault: true,
  pool: { min: 1, max: 5 }
});

// Auto-create tables if they don't exist
async function ensureSchema() {
  if (!(await knex.schema.hasTable('users'))) {
    await knex.schema.createTable('users', t => {
      t.string('id').primary();
      t.string('email').notNullable().unique();
      t.string('password_hash').notNullable();
      t.string('name').nullable();
      t.timestamp('created_at').defaultTo(knex.fn.now());
    });
  }

  if (!(await knex.schema.hasTable('transactions'))) {
    await knex.schema.createTable('transactions', t => {
      t.string('id').primary();
      t.string('user_id').notNullable().references('id').inTable('users').onDelete('CASCADE');
      t.decimal('amount', 12, 2).notNullable();
      t.date('date').notNullable();
      t.string('description').notNullable();
      t.string('category').notNullable();
      t.timestamp('created_at').defaultTo(knex.fn.now());
      t.timestamp('updated_at').nullable();
    });
  }

  if (!(await knex.schema.hasTable('budgets'))) {
    await knex.schema.createTable('budgets', t => {
      t.string('id').primary();
      t.string('user_id').notNullable().references('id').inTable('users').onDelete('CASCADE');
      t.string('category').notNullable();
      t.decimal('limit', 12, 2).defaultTo(0);
      t.decimal('spent', 12, 2).defaultTo(0);
      t.timestamp('created_at').defaultTo(knex.fn.now());
    });
  }

  if (!(await knex.schema.hasTable('goals'))) {
    await knex.schema.createTable('goals', t => {
      t.string('id').primary();
      t.string('user_id').notNullable().references('id').inTable('users').onDelete('CASCADE');
      t.string('name').notNullable();
      t.decimal('target', 12, 2).defaultTo(0);
      t.decimal('saved', 12, 2).defaultTo(0);
      t.date('due_date').nullable();
      t.timestamp('created_at').defaultTo(knex.fn.now());
    });
  }

  if (!(await knex.schema.hasTable('subscriptions'))) {
    await knex.schema.createTable('subscriptions', t => {
      t.string('id').primary();
      t.string('user_id').notNullable().references('id').inTable('users').onDelete('CASCADE');
      t.string('name').notNullable();
      t.string('category').defaultTo('Other');
      t.decimal('amount', 12, 2).defaultTo(0);
      t.string('frequency').defaultTo('Monthly');
      t.date('next_due').nullable();
      t.timestamp('created_at').defaultTo(knex.fn.now());
    });
  }

  if (!(await knex.schema.hasTable('earnings'))) {
    await knex.schema.createTable('earnings', t => {
      t.string('id').primary();
      t.string('user_id').notNullable().references('id').inTable('users').onDelete('CASCADE');
      t.string('source').notNullable();
      t.decimal('amount', 12, 2).defaultTo(0);
      t.timestamp('created_at').defaultTo(knex.fn.now());
    });
  }
}

ensureSchema().catch(err => {
  console.error('Error creating schema', err);
  process.exit(1);
});

// --- Auth helpers
function signToken(payload) {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });
}

async function requireAuth(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing token' });
  const token = auth.slice(7);
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    const user = await knex('users').where({ id: payload.id }).first();
    if (!user) return res.status(401).json({ error: 'Invalid token (user not found)' });
    req.user = { id: user.id, email: user.email, name: user.name };
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// --- AUTH ROUTES
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, name } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'email and password required' });
    const existing = await knex('users').where({ email }).first();
    if (existing) return res.status(409).json({ error: 'User already exists' });
    const hashed = await bcrypt.hash(password, BCRYPT_ROUNDS);
    const id = uuidv4();
    await knex('users').insert({ id, email, password_hash: hashed, name: name || null });
    const token = signToken({ id, email });
    res.status(201).json({ user: { id, email, name: name || null }, token });
  } catch (err) {
    console.error('register error', err);
    res.status(500).json({ error: 'server error' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'email and password required' });
    const user = await knex('users').where({ email }).first();
    if (!user) return res.status(401).json({ error: 'invalid credentials' });
    const ok = await bcrypt.compare(password, user.password_hash);
    if (!ok) return res.status(401).json({ error: 'invalid credentials' });
    const token = signToken({ id: user.id, email: user.email });
    res.json({ user: { id: user.id, email: user.email, name: user.name }, token });
  } catch (err) {
    console.error('login error', err);
    res.status(500).json({ error: 'server error' });
  }
});

// --- CRUD helpers for per-user resources
function makeRouterFor(tableName, requiredFields = []) {
  const router = express.Router();

  router.get('/', requireAuth, async (req, res) => {
    const items = await knex(tableName).where({ user_id: req.user.id }).orderBy('created_at', 'desc');
    res.json(items);
  });

  router.post('/', requireAuth, async (req, res) => {
    try {
      const data = req.body || {};
      for (const f of requiredFields) if (data[f] === undefined) return res.status(400).json({ error: `${f} required` });
      const id = data.id || uuidv4();
      const row = { ...data, id, user_id: req.user.id };
      await knex(tableName).insert(row);
      const inserted = await knex(tableName).where({ id }).first();
      res.status(201).json(inserted);
    } catch (err) {
      console.error('post error', err);
      res.status(500).json({ error: 'server error' });
    }
  });

  router.get('/:id', requireAuth, async (req, res) => {
    const row = await knex(tableName).where({ id: req.params.id, user_id: req.user.id }).first();
    if (!row) return res.status(404).json({ error: 'not found' });
    res.json(row);
  });

  router.put('/:id', requireAuth, async (req, res) => {
    try {
      const updated = { ...req.body, updated_at: knex.fn.now() };
      await knex(tableName).where({ id: req.params.id, user_id: req.user.id }).update(updated);
      const row = await knex(tableName).where({ id: req.params.id, user_id: req.user.id }).first();
      if (!row) return res.status(404).json({ error: 'not found' });
      res.json(row);
    } catch (err) {
      console.error('put error', err);
      res.status(500).json({ error: 'server error' });
    }
  });

  router.delete('/:id', requireAuth, async (req, res) => {
    const row = await knex(tableName).where({ id: req.params.id, user_id: req.user.id }).first();
    if (!row) return res.status(404).json({ error: 'not found' });
    await knex(tableName).where({ id: req.params.id, user_id: req.user.id }).del();
    res.json({ removed: row });
  });

  return router;
}

// Register routers
app.use('/api/transactions', makeRouterFor('transactions', ['amount','date','description','category']));
app.use('/api/budgets', makeRouterFor('budgets', ['category']));
app.use('/api/goals', makeRouterFor('goals', ['name','due_date'])); // target/saved optional
app.use('/api/subscriptions', makeRouterFor('subscriptions', ['name','next_due']));
app.use('/api/earnings', makeRouterFor('earnings', ['source']));

// metrics (per-user)
app.get('/api/metrics', requireAuth, async (req, res) => {
  const tx = await knex('transactions').where({ user_id: req.user.id });
  const subs = await knex('subscriptions').where({ user_id: req.user.id });
  const earnings = await knex('earnings').where({ user_id: req.user.id });

  const totalExpenses = tx.reduce((s,t) => s + Number(t.amount || 0), 0);
  const totalIncome = earnings.reduce((s,e) => s + Number(e.amount || 0), 0);

  const now = new Date();
  const horizon = new Date(now.getTime() + 30*24*3600*1000);
  const upcoming = subs.filter(s => s.next_due && new Date(s.next_due) >= now && new Date(s.next_due) <= horizon);
  const upcomingTotal = upcoming.reduce((s,u) => s + Number(u.amount || 0), 0);

  res.json({ totalExpenses, totalIncome, upcoming: { count: upcoming.length, total: upcomingTotal } });
});

// AI insight mock
app.post('/api/ai-insight', requireAuth, async (req, res) => {
  const { prompt = '' } = req.body;
  const tx = await knex('transactions').where({ user_id: req.user.id });
  const total = tx.reduce((s,t) => s + Number(t.amount || 0), 0);
  const reply = [
    `You have ${tx.length} transactions totaling ₹${total.toFixed(2)}.`,
    prompt ? `Regarding: \"${prompt}\" — try cutting one recurring item and save that each month.` : `Tip: set a weekly budget and automate one saving transfer.`
  ].join(' ');
  setTimeout(() => res.json({ text: reply }), 200); // small delay for UX
});

// Fallback - Serve index.html for SPA
app.use((req, res) => {
  const index = path.join(__dirname, 'public', 'index.html');
  if (fs.existsSync(index)) res.sendFile(index);
  else res.status(404).send('No frontend found. Put index.html in /public');
});

// Start server
app.listen(PORT, () => {
  console.log(`FinanceEase backend (SQLite) listening on http://localhost:${PORT}`);
});
